#!/usr/bin/env python3
"""
skill_inventory.py — Auto-generate a skill manifest from SKILL.md files.

Scans .cursor/skills/ and .claude/skills/ for SKILL.md files,
extracts YAML frontmatter (name, description), gets last-modified
date from git, and outputs a markdown table to docs/_generated/skill-manifest.md.

Stdlib-only — no PyYAML dependency.
"""

import os
import re
import subprocess
import sys

REPO_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
OUTPUT_PATH = os.path.join(REPO_ROOT, "docs", "_generated", "skill-manifest.md")
SKILL_DIRS = [
    os.path.join(REPO_ROOT, ".cursor", "skills"),
    os.path.join(REPO_ROOT, ".claude", "skills"),
]


def extract_frontmatter(filepath):
    """Extract name and description from YAML frontmatter using regex."""
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
    except (OSError, UnicodeDecodeError):
        return None, None

    # Match YAML frontmatter between --- delimiters
    match = re.match(r"^---\s*\n(.*?)\n---", content, re.DOTALL)
    if not match:
        return None, None

    frontmatter = match.group(1)

    name = None
    description = None

    name_match = re.search(r"^name:\s*(.+)$", frontmatter, re.MULTILINE)
    if name_match:
        name = name_match.group(1).strip().strip("\"'")

    desc_match = re.search(r"^description:\s*(.+)$", frontmatter, re.MULTILINE)
    if desc_match:
        description = desc_match.group(1).strip().strip("\"'")

    return name, description


def get_git_date(filepath):
    """Get last modified date from git log."""
    try:
        result = subprocess.run(
            ["git", "log", "-1", "--format=%ai", "--", filepath],
            capture_output=True, text=True, cwd=REPO_ROOT, timeout=10
        )
        if result.returncode == 0 and result.stdout.strip():
            # Format: "2026-02-18 14:30:00 -0500" → "2026-02-18"
            return result.stdout.strip().split(" ")[0]
    except (subprocess.TimeoutExpired, OSError):
        pass
    return "unknown"


def get_relative_location(filepath):
    """Get the skill location relative to repo root (directory only)."""
    rel = os.path.relpath(os.path.dirname(filepath), REPO_ROOT)
    # Return the top-level skill dir (e.g., ".cursor/skills/")
    parts = rel.split(os.sep)
    if len(parts) >= 2:
        return os.path.join(parts[0], parts[1]) + "/"
    return rel + "/"


def main():
    skills = []

    for skill_dir in SKILL_DIRS:
        if not os.path.isdir(skill_dir):
            continue
        for entry in os.listdir(skill_dir):
            skill_md = os.path.join(skill_dir, entry, "SKILL.md")
            if not os.path.isfile(skill_md):
                continue

            name, description = extract_frontmatter(skill_md)
            if not name:
                name = entry  # fallback to directory name

            if description and len(description) > 80:
                description = description[:77] + "..."

            git_date = get_git_date(skill_md)
            location = get_relative_location(skill_md)

            skills.append({
                "name": name,
                "description": description or "(no description)",
                "location": location,
                "last_modified": git_date,
            })

    # Sort alphabetically by name
    skills.sort(key=lambda s: s["name"].lower())

    # Generate markdown
    os.makedirs(os.path.dirname(OUTPUT_PATH), exist_ok=True)

    lines = [
        "# Skill Manifest",
        "",
        f"> Auto-generated by `skill_inventory.py` — {len(skills)} skills indexed.",
        "> Do not edit manually.",
        "",
        "| # | Skill | Description | Location | Last Modified |",
        "|---|-------|-------------|----------|---------------|",
    ]

    for i, skill in enumerate(skills, 1):
        lines.append(
            f"| {i} | {skill['name']} | {skill['description']} | {skill['location']} | {skill['last_modified']} |"
        )

    lines.append("")  # trailing newline

    with open(OUTPUT_PATH, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    print(f"Skill manifest written: {len(skills)} skills → {OUTPUT_PATH}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
